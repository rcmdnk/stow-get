#!/usr/bin/env bash

## Description {{{
#
# Package manager with stow.
#
STOW_GET_VERSION=v0.0.1
STOW_GET_DATE="1/May/2017"
#
# }}}

# The MIT License (MIT) {{{
#
# Copyright (c) 2017 rcmdnk
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# }}}

# Fixed values {{{
EXIT_WRONG_ARG=100
EXIT_UNKNOWN_COMMAND=101
EXIT_NO_PACKAEGE=102
EXIT_CD_FAIL=103
EXIT_WRONG_BIN_DEP=104
EXIT_WRONG_LIB_DEP=105
EXIT_NO_PAC_CONF=106
EXIT_NO_VERSION=107
EXIT_NOT_GNU=108
# }}}

# Default variables {{{
function set_inst_dir {
  inst_dir="$1"
  stow_dir="$inst_dir/stow"
}

function set_default {
  set_inst_dir "$HOME/usr/local"
  script_dir=$(cd "$(dirname "$0")";pwd)
  conf_dir="$script_dir/../share/stow-get"
  conf_file="$HOME/.stow-get"
  default_inst_type=""
  force=0
  dryrun=0
  packages=()
  verbose=0
}
set_default
# }}}

# Global variables for installation {{{
function reset_inst_val {
  version=""
  inst_type=""
  target=""
  url_prefix=""
  tarball=""
  user=""
  repository=""
  directory=""
  configure="./configure"
  configure_options=""

  bin_dep=()
  lib_dep=()


  unset stow_install
  function before_configure {
    :
  }
  function make_cmd {
    make all && make install
  }
}
reset_inst_val
# }}}

# functions {{{

function show_help { # {{{
  ret="$1"
  set_default
  echo "
Usage: stow-get <sub command> [-fDVvh] [-c <conf file>] [-d <conf dir>] [-i <inst dir> ] [-t <inst type>] [package [package [...]]]

Sub commands:
   install [package [package...]]
                  Install packages (all packages in the configuration file if no package is given).
   uninstall <package>
                  Remove package.
   rm/remove      Aliases of uninstall.
   list           List up installed packages.
   packages       List up available packages which have configuration files.
   info <package> Show configuration file of package.
   get_latest  <package>
   Show the latest version of package (only for GNU packages).
   version        Show version.
   help           Show this help.

Arguments:
   -c <conf file> Configuration file (default: $conf_file).
   -d <conf dir>  Directory which has package configuration files (default: $conf_dir).
   -i <inst dir>  Directory to install packages (default: $inst_dir).
   -t <inst type> Set install type: only for install with package name (default: $default_inst_type).
   -f             Force to re-install.
   -D             Dry run mode.
   -V             Verbose mode.
   -v             Show version.
   -h             Show this help.

See more details at: https://github.com/rcmdnk/stow-get
"
  if [ "$ret" != "" ];then
    exit "$ret"
  fi
} ## }}}

function banner { ## {{{
  echo "####################################################################"
  echo "$@"
  echo "####################################################################"
} ## }}}

function banner_v { ## {{{
  if [ $verbose -eq 1 ];then
    banner "$@"
  fi
} ## }}}

function warn { ## {{{
  printf "\e[33m"
  banner "WARNING: $*"
  printf "\e[m"
} ## }}}

function err { ## {{{
  printf "\e[31m" 1>&2
  banner "ERROR: $*" 1>&2
  printf "\e[m" 1>&2
  return 1
} ## }}}

function cd_check { ## {{{
  dir="$1"
  no_exit="$2"
  cd "$dir" || err "can not cd to $dir."
  ret=$?
  if [ $ret != 0 ] && [ "$no_exit" = "" ];then
    exit $EXIT_CD_FAIL
  fi
  return $ret
} ## }}}

function get_pac_conf { # {{{
  pac_conf="$conf_dir/${1}.sh"
  is_exit="${2:-1}"
  if [ ! -f "$pac_conf" ];then
    if [ "$is_exit" -eq 1 ];then
      err "No configuration file for $1 is found."
      exit $EXIT_NO_PAC_CONF
    fi
    pac_conf=""
  fi
} # }}}

function source_pac_conf { # {{{
  reset_inst_val
  is_exit=1
  if [ "$default_inst_type" != "" ];then
    inst_type="$default_inst_type"
    is_exit=0
  fi
  get_pac_conf "$package" "$is_exit"
  if [ "$pac_conf" != "" ];then
    source "$pac_conf"
  fi
  set_target
} # }}}

function set_version { # {{{
  if [ "$version" = "" ] || [ "$version" = "latest" ];then
    if [ "$inst_type" = "gnu" ];then
      get_gnu_latest "$package"
    else
      err "version(=$version) is not recognized for $package."
      exit $EXIT_NO_VERSION
    fi
  fi
} # }}}

function set_target { # {{{
  set_version
  target=${package}-STOW-${version}
} # }}}

function clean_package { # {{{
  cd_check "$stow_dir" 1 >/dev/null 2>&1
  ret=$?
  if [ $ret -eq 0 ];then
    local pdirs=$(ls -d "${package}-STOW-"* 2>/dev/null)
    if [ "$pdirs" != "" ];then
      stow -D "${package}-STOW-"*
      rm -rf "${package}-STOW-"*
    fi
  fi
} # }}}

function check_bin { ## {{{
  type -a "$1" >/dev/null 2>&1
} ## }}}

function check_lib { # {{{
  IFS_ORIG=$IFS
  IFS=$'\n'
  pathes=(${LD_LIBRARY_PATH//:/$'\n'})
  IFS=$IFS_ORIG
  for d in "${pathes[@]}";do
    files=$(ls "$d/${1}"* 2>/dev/null)
    if [ "$files" != "" ];then
      return 0
    fi
  done
  return 1
} # }}}

function get_tarball  { # {{{
  wget --no-check-certificate "$1"
  ret=$?
  if [ $ret -ne 0 ];then
    return $ret
  fi
  if echo "$1"|grep -q "tar.gz$";then
    tar xzf "${1##*/}"
  elif echo $tarball|grep -q "tar.xz$";then
    tar Jxf "${1##*/}"
  elif echo $tarball|grep -q "tar.bz2$";then
    tar jxf "${1##*/}"
  elif echo $tarball|grep -q "zip$";then
    unzip "${1##*/}"
  fi
} # }}}

function stow_install_tarball { ## {{{
  directory=${directory:-${target/-STOW/}}
  tarball=${tarball:-${directory}.tar.gz}
  get_tarball "$url_prefix/$tarball"
  ret=$?
  if [ $ret -ne 0 ];then
    return $ret
  fi

  cd_check "$directory" 1
  ret=$?
  if [ $ret -ne 0 ];then
    return $ret
  fi

  before_configure
  ret=$?
  if [ $ret -ne 0 ];then
    return $ret
  fi

  if [ "$configure" != "" ];then
    CFLAGS="-L$inst_dir/lib -I$inst_dir/include" \
      CPPFLAGS="-L$inst_dir/lib -I$inst_dir/include" \
      LDFLAGS="-L$inst_dir/lib" \
      "$configure" --prefix="$stow_dir/$target" "$configure_options"
    ret=$?
    if [ $ret -ne 0 ];then
      return $ret
    fi
  fi

  make_cmd
} ## }}}

function stow_install_gnu { ## {{{
  url_prefix=${url_prefix:-http://ftp.gnu.org/gnu/$package}
  stow_install_tarball
} ## }}}

function get_gnu_latest { ## {{{
  local p="$1"
  local output_time="${2:-0}"
  local url="http://ftp.gnu.org/gnu/$p/?C=M;O=A"
  local html="$(curl "$url" 2>/dev/null)"
  local latest="$(printf "$html"|grep "$p"|grep ".tar.gz<"|grep "$1"|grep -v "\-doc\-"|grep -v latest|tail -n1)"
  local params=$(echo "$latest"|sed 's/<[^>]*>/ /g')
  if [ "$params" = "" ];then
    err "$p is not a GNU package."
    exit $EXIT_NOT_GNU
  fi
  version=$(echo "$params"|awk -v p="$p" '{sub(p"-", "", $1)}{sub(".tar.gz", "", $1)}{print $1}')
  if [ "$output_time" -eq 1 ];then
    printf "%15s %8s %8s %3s %10s %5s %5s\n" $(echo "$params"|awk -v p="$p" '{sub(p"-", "", $1)}{sub(".tar.gz", "", $1)}{print p " " $1 "    updated at: " $2 " " $3 " " $4}')
  fi
} ## }}}

function stow_install_github { ## {{{
  tarball=${tarball:-v${version}.tar.gz}
  user=${user:-${package}}
  repository=${repository:-${package}}
  url_prefix=${url_prefix:-https://github.com/$user/$repository/archive}
  stow_install_tarball
} ## }}}

function stow_install_github_direct { ## {{{
  configure=""
  function make_cmd {
    cp -r . "$stow_dir/$target"
  }
  stow_install_github
} ## }}}

function stow_install_wrapper { ## {{{
  cd_check "$TMP_DIR"

  if [ "$inst_type" = "tarball" ];then
    stow_install_tarball
  elif [ "$inst_type" = "gnu" ];then
    stow_install_gnu
  elif [ "$inst_type" = "github" ];then
    stow_install_github
  elif [ "$inst_type" = "github_direct" ];then
    stow_install_github_direct
  elif [ "$inst_type" != "" ];then
    err "Invalid inst_type: $inst_type"
    return 1
  else
    if ! eval type -a stow_install > /dev/null 2>&1;then
      err "Neither type nor stow_install is not defined for $package."
      return 1
    fi
    stow_install
  fi
} ## }}}

# }}} functions

# Check argumetns {{{

COMMANDS=(install rm remove uninstall list packages info get_latest version help)
NEED_ARGS=(uninstall info get_latest)

if [ "$#" -eq 0 ] || [ "$1" = "help" ] || [ "$1" = "-h" ];then
  show_help 0
elif [ "$1" = "version" ] || [ "$1" = "-v" ];then
  echo "$(basename "$0") $STOW_GET_VERSION $STOW_GET_DATE"
  exit 0
fi

if ! echo " ${COMMANDS[*]} "|grep -q " $1 ";then
  err "Unknown command: $1"
  exit $EXIT_UNKNOWN_COMMAND
fi
command=$1
shift
if [ "$command" = "rm" ] || [ "$command" = "remove" ];then
  command="uninstall"
fi

while getopts c:d:i:t:fDVvh OPT;do
  case $OPT in
    "c" ) conf_file="$OPTARG" ;;
    "d" ) conf_dir="$OPTARG" ;;
    "i" ) set_inst_dir "$OPTARG" ;;
    "t" ) default_inst_type="$OPTARG" ;;
    "f" ) force=1 ;;
    "D" ) dryrun=1 ;;
    "V" ) verbose=1 ;;
    "v" ) echo "$(basename "$0") $STOW_GET_VERSION $STOW_GET_DATE"; exit 0;;
    "h" ) show_help 0;;
    * ) echo "Check \"$(basename "$0") -h\" for more information" >/dev/tty;exit $EXIT_WRONG_ARG;;

  esac
done
shift $((OPTIND - 1))

if echo " ${NEED_ARGS[*]} "|grep -q " $command ";then
  if [ "$#" -eq 0 ];then
    err "Need <package> argument for $command command."
    exit $EXIT_NO_PACKAEGE
  fi
fi

if [ "$command" = "get_latest" ];then
  packages=("$@")
  for package in "$@";do
    get_gnu_latest "$package" 1
  done
  exit
fi
# }}}

# Read configuration {{{
if [ -f "$conf_file" ];then
  source "$conf_file"
fi
if [ "$#" -ne 0 ];then
  packages=("$@")
fi
# }}}

# Info {{{
if [ "$command" = "info" ];then
  for package in "${packages[@]}";do
    get_pac_conf "$package" 1
    banner "Configuration for $package"
    cat "$pac_conf"
  done
  exit
fi
# }}}

# List {{{
if [ "$command" = "list" ];then
  echo $(ls "$stow_dir"|awk '{split($1, tmp, "-STOW-")}{print tmp[1]}')
  exit
fi
# }}}

# Packages {{{
if [ "$command" = "packages" ];then
  echo $(ls "$conf_dir"|sed 's/.sh$//')
  exit
fi
# }}}

# Check PATH/LD_LIBRARY_PATH
if ! echo "$PATH"| grep -q "$inst_dir/bin";then
  warn "PATH doesn't include $inst_dir/bin,
which may make a problem to search dependencies or to use stow command."
fi
if ! echo "$LD_LIBRARY_PATH"| grep -q "$inst_dir/lib";then
  warn "LD_LIBRARY_PATH doesn't include $inst_dir/lib,
which may make a problem to search dependencies."
fi

# Check stow {{{
if ! type -a stow >/dev/null 2>&1;then
  packages=(stow "${packages[@]}")
fi
# }}}

# Uninstall {{{
if [ "$command" = "uninstall" ];then
  for package in "${packages[@]}";do
    source_pac_conf
    banner "Uninstalling $stow_dir/${package}-STOW-\*"
    clean_package
  done
  exit
fi
# }}}

# Dependency check {{{
i=0
pre_packages=()
while [ "$i" -lt "${#packages[@]}" ];do
  package="${packages[$i]}"
  source_pac_conf
  deps=0
  j=0
  while [ "$j" -lt ${#bin_dep[@]} ];do
    p=${bin_dep[j+1]}
    if [ "$p" = "" ];then
      err "Configuration file for $p has wrong bin_dep definition."
      exit $EXIT_WRONG_BIN_DEP
    fi
    if ! check_bin "${bin_dep[j]}";then
      if ! echo " ${pre_packages[*]} "|grep -q " $p ";then
        if echo " ${packages[*]} "|grep -q " $p ";then
          packages=($(echo " ${packages[*]} "|sed "s/ $p / /"))
        fi
        packages=($(echo " ${packages[*]} "|sed "s/ $package / $p $package /"))
        deps=1
      fi
    fi
    j=$((j+2))
  done
  j=0
  while [ "$j" -lt ${#lib_dep[@]} ];do
    p=${lib_dep[j+1]}
    if [ "$p" = "" ];then
      err "Configuration file for $p has wrong lib_dep definition."
      exit $EXIT_WRONG_LIB_DEP
    fi
    if ! check_lib "${lib_dep[j]}";then
      if ! echo " ${pre_packages[*]} "|grep -q " $p ";then
        if echo " ${packages[*]} "|grep -q " $p ";then
          packages=($(echo " ${packages[*]} "|sed "s/ $p / /"))
        fi
        packages=($(echo " ${packages[*]} "|sed "s/ $package / $p $package /"))
        deps=1
      fi
    fi
    j=$((j+2))
  done
  if [ $deps -eq 0 ];then
    pre_packages=("${pre_packages[@]}" "$package")
    ((i++))
  fi
done
# }}}

# Prepare tmp dir/path {{{
TMP_DIR=$(mktemp -d)
trap 'rm -rf "$TMP_DIR"' EXIT HUP INT QUIT ABRT SEGV TERM
# }}}

# Main loop {{{
for package in "${packages[@]}";do
  source_pac_conf

  if [ "$package" = "stow" ];then
    export PATH=$stow_dir/$target/bin:$PATH
  fi

  if [ -d "$stow_dir/$target" ];then
    banner_v "$target was already installed."
    if [ "$force" -eq 1 ];then
      banner_v "Reinstall $target."
      if [ $dryrun -eq 0 ];then
        cd_check "$stow_dir"
        stow -D "$target"
        rm -rf "$target"
      fi
    else
      if [ $dryrun -eq 0 ];then
        cd_check "$stow_dir"
        stow --ignore="share/info/dir" "$target"
      fi
      continue
    fi
  fi

  banner "Installing $stow_dir/$target"

  if [ $dryrun -eq 1 ];then
    continue
  fi

  # Delte old stow package
  clean_package

  # Install
  if [ "$verbose" -eq 1 ];then
    stow_install_wrapper
  else
    log=$(stow_install_wrapper 2>&1)
  fi
  ret=$?

  if [ $ret -ne 0 ];then
    if [ "$verbose" -eq 0 ];then
      echo "$log"
    fi
    err "Failed to install $package"
    exit $ret
  fi

  cd_check "$stow_dir"

  # Install. ignore share/info/dir which causes a conflict sometime.
  stow --ignore="share/info/dir" "$target"
  ret=$?
  if [ $ret -ne 0 ];then
    err "Failed to place by stow."
    exit $ret
  fi
done # }}}

# vim: foldmethod=marker
# vim: foldmarker={{{,}}}
