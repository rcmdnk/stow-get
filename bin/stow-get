#!/usr/bin/env bash

## Description {{{
#
# Package manager with stow.
#
STOW_GET_VERSION=v0.0.6
STOW_GET_DATE="13/Jun/2017"
#
# }}}

# The MIT License (MIT) {{{
#
# Copyright (c) 2017 rcmdnk
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# }}}

# Fixed values {{{
EXIT_WRONG_ARG=100
EXIT_UNKNOWN_COMMAND=101
EXIT_NO_PACKAEGE=102
EXIT_CD_FAIL=103
EXIT_WRONG_BIN_DEP=104
EXIT_WRONG_LIB_DEP=105
EXIT_NO_PAC_CONF=106
EXIT_NO_VERSION=107
EXIT_NOT_GNU=108
EXIT_INVALID_INST_TYPE=109
EXIT_NO_STOW_INSTALL=110
# }}}

# Default variables {{{
function set_inst_dir {
  inst_dir="$1"
  stow_dir="$inst_dir/stow"
  current_dir="$stow_dir/current"
}

function set_default {
  set_inst_dir "$HOME/usr/local"
  script_dir=$(cd "$(dirname "$0")";pwd)
  conf_dir=("$script_dir/../share/stow-get")
  conf_file="$HOME/.stow-get"
  default_inst_type="gnu"
  force=0
  dryrun=0
  packages=()
  verbose=0
}
set_default
# }}}

# Global variables for installation {{{
function reset_inst_val {
  version=""
  inst_type=""
  target=""
  target_postfix=""
  url_prefix=""
  tarball=""
  user=""
  repository=""
  directory=""
  configure="./configure"
  configure_options=""

  bin_dep=()
  lib_dep=()


  unset stow_install
  function before_configure {
    :
  }
  function make_cmd {
    make all && make install
  }
  function get_latest {
    if [ "$inst_type" = "gnu" ];then
      get_gnu_latest "$@"
    elif [ "$inst_type" = "github" ];then
      get_github_latest "$@"
    elif [ "$inst_type" = "github_direct" ];then
      get_github_direct_latest "$@"
    else
      err "get_latest is undefined for $inst_type"
    fi
    if [ "$version" = "" ];then
      err "Failed to get version for $package."
      exit $EXIT_NO_VERSION
    fi
  }
}
reset_inst_val
# }}}

# functions {{{

function show_help { # {{{
  ret="$1"
  set_default
  echo "
Usage: stow-get <sub command> [-fDVvh] [-c <conf file>] [-d <conf dir>] [-i <inst dir> ] [-t <inst type>] [package [package [...]]]

Sub commands:
   install [package [package...]]
                  Install packages (all packages in the configuration file if no package is given).
   uninstall <package>
                  Remove package.
   rm/remove      Aliases of uninstall.
   list           List up installed packages.
   packages       List up available packages which have configuration files.
   cleanup        Clean up old packages
   info <package> Show configuration file of package.
   latest <package>
                  Show the latest version of package.
   version        Show version.
   help           Show this help.

Arguments:
   -c <conf file> Configuration file (default: $conf_file).
   -d <conf dir>  Additional directory of package configuration files (default: ${conf_dir[*]}).
                  Multi directories can be specified by separating with \",\".
   -i <inst dir>  Directory to install packages (default: $inst_dir).
   -t <inst type> Set install type (default: $default_inst_type).
   -f             Force to re-install.
   -D             Dry run mode.
   -V             Verbose mode.
   -v             Show version.
   -h             Show this help.

See more details at: https://github.com/rcmdnk/stow-get
"
  if [ "$ret" != "" ];then
    exit "$ret"
  fi
} ## }}}

function show_version { ## {{{
  echo "$(basename "$0") $STOW_GET_VERSION $STOW_GET_DATE"
} ## }}}

function banner { ## {{{
  echo "####################################################################"
  echo "$@"
  echo "####################################################################"
} ## }}}

function banner_v { ## {{{
  if [ $verbose -eq 1 ];then
    banner "$@"
  fi
} ## }}}

function warn { ## {{{
  printf "\e[33m"
  banner "WARNING: $*"
  printf "\e[m"
} ## }}}

function err { ## {{{
  printf "\e[31m" 1>&2
  banner "ERROR: $*" 1>&2
  printf "\e[m" 1>&2
  return 1
} ## }}}

function cd_check { ## {{{
  dir="$1"
  no_exit="$2"
  cd "$dir" || err "can not cd to $dir."
  ret=$?
  if [ $ret != 0 ] && [ "$no_exit" = "" ];then
    exit $EXIT_CD_FAIL
  fi
  return $ret
} ## }}}

function get_pac_conf { ## {{{
  conf_name="${1}.sh"
  is_exit="${2:-0}"
  pac_conf=""
  for d in "${conf_dir[@]}";do
    if [ -f "${d}/${conf_name}" ];then
      pac_conf="${d}/${conf_name}"
      break
    fi
  done
  if [ "$pac_conf" = "" ];then
    banner_v "No configuration file for $1 is found."
    if [ "$is_exit" -eq 1 ];then
      exit $EXIT_NO_PAC_CONF
    else
      return 1
    fi
  fi
} ## }}}

function source_pac_conf { ## {{{
  reset_inst_val
  get_pac_conf "$package"
  if [ "$pac_conf" != "" ];then
    source "$pac_conf"
  fi
  if [ "$inst_type" = "" ];then
    warn "No inst_type is given. Trying to $default_inst_type type installation."
    inst_type=$default_inst_type
  fi
  set_target

  local init_type=init_"$inst_type"
  if ! check_bin "$init_type" >/dev/null 2>&1;then
    err "Invalid inst_type: $inst_type for $package"
    return $EXIT_INVALID_INST_TYPE
  fi
  eval init_"$inst_type"
} ## }}}

function set_version { # {{{
  if [ "$version" = "" ] || [ "$version" = "latest" ];then
    get_latest
    ret=$?
    if [ $ret -ne 0 ];then
      err "version(=$version) is not recognized for $package."
      err "Set version or get_latest function."
      exit $EXIT_NO_VERSION
    fi
  fi
} # }}}

function set_target { # {{{
  set_version
  target=${package}-STOW-${target_postfix:-${version}}
} # }}}

function cleanup_package { # {{{
  local target_tmp=$target
  local current_list=$(get_file_list "$current_dir" "*-STOW-*")
  local dir_list=$(get_dir_list "$stow_dir" "*-STOW-*")
  for d in ${dir_list};do
    if ! echo "$current_list"|grep -q "^${d}$";then
      target="$d"
      rm_package 1
    fi
  done
  target=$target_tmp
} # }}}

function check_bin { ## {{{
  type -a "$1" >/dev/null 2>&1
} ## }}}

function check_lib { # {{{
  IFS_ORIG=$IFS
  IFS=$'\n'
  pathes=(${LD_LIBRARY_PATH//:/$'\n'})
  IFS=$IFS_ORIG
  for d in "${pathes[@]}";do
    files=$(get_file_list "$d" "${1}"* 2>/dev/null)
    if [ "$files" != "" ];then
      return 0
    fi
  done
  return 1
} # }}}

function get_tarball  { # {{{
  wget --no-check-certificate "$1"
  ret=$?
  if [ $ret -ne 0 ];then
    return $ret
  fi
  if echo "$1"|grep -q "tar.gz$";then
    tar zxf "${1##*/}"
  elif echo $tarball|grep -q "tgz$";then
    tar zxf "${1##*/}"
  elif echo $tarball|grep -q "tar.xz$";then
    tar Jxf "${1##*/}"
  elif echo $tarball|grep -q "tar.bz2$";then
    tar jxf "${1##*/}"
  elif echo $tarball|grep -q "tar.Z$";then
    tar zxf "${1##*/}"
  elif echo $tarball|grep -q "tar$";then
    tar xf "${1##*/}"
  elif echo $tarball|grep -q "zip$";then
    unzip "${1##*/}"
  fi
} # }}}

function init_tarball { ## {{{
  directory=${directory:-${package}-${version}}
  tarball=${tarball:-${directory}.tar.gz}

  if ! check_bin stow_install;then
    function stow_install {
      get_tarball "$url_prefix/$tarball"
      ret=$?
      if [ $ret -ne 0 ];then
        return $ret
      fi

      cd_check "$directory" 1
      ret=$?
      if [ $ret -ne 0 ];then
        return $ret
      fi

      before_configure
      ret=$?
      if [ $ret -ne 0 ];then
        return $ret
      fi

      if [ "$configure" != "" ];then
        CFLAGS="-L$inst_dir/lib -I$inst_dir/include" \
          CPPFLAGS="-L$inst_dir/lib -I$inst_dir/include" \
          LDFLAGS="-L$inst_dir/lib" \
          "$configure" --prefix="$stow_dir/$target" "$configure_options"
        ret=$?
        if [ $ret -ne 0 ];then
          return $ret
        fi
      fi

      make_cmd
    }
  fi
} ## }}}

function init_gnu { ## {{{
  url_prefix=${url_prefix:-http://ftp.gnu.org/gnu/$package}
  init_tarball
} ## }}}

function init_github { ## {{{
  tarball=${tarball:-v${version}.tar.gz}
  user=${user:-${package}}
  repository=${repository:-${package}}
  url_prefix=${url_prefix:-https://github.com/$user/$repository/archive}
  init_tarball
} ## }}}

function init_github_direct { ## {{{
  configure=""
  function make_cmd {
    cp -r . "$stow_dir/$target"
  }
  init_github
} ## }}}

function stow_install_wrapper { ## {{{
  cd_check "$TMP_DIR"

  if ! check_bin stow_install;then
    err "stow_install function is not set."
    return $EXIT_NO_STOW_INSTALL
  fi
  stow_install
} ## }}}

function get_gnu_latest { ## {{{
  local output_detail="${1:-0}"
  local url="http://ftp.gnu.org/gnu/$package/?C=M;O=A"
  local html="$(curl "$url" 2>/dev/null)"
  local latest="$(printf "$html"|grep "$package"|grep ".tar.gz<"|grep "$1"|grep -v "\-doc\-"|grep -v latest|tail -n1)"
  local params=$(echo "$latest"|sed 's/<[^>]*>/ /g')
  if [ "$params" = "" ];then
    err "$package is not a GNU package."
    exit $EXIT_NOT_GNU
  fi
  version=$(echo "$params"|awk -v p="$package" '{sub(p"-", "", $1)}{sub(".tar.gz", "", $1)}{print $1}')
  if [ "$output_detail" -eq 1 ];then
    printf "%15s %8s %8s %3s %10s %5s %5s\n" $(echo "$params"|awk -v p="$package" '{sub(p"-", "", $1)}{sub(".tar.gz", "", $1)}{print p " " $1 "    updated at: " $2 " " $3 " " $4}')
  fi
} ## }}}

function get_github_latest { ## {{{
  user=${user:-${package}}
  repository=${repository:-${package}}
  local output_detail="${1:-0}"
  local info=""
  local json=$(curl https://api.github.com/repos/$user/$repository/releases/latest 2>/dev/null)
  version=$(echo "$json"|grep "\"name\":"|cut -d":" -f2|cut -d '"' -f2|sed 's/^v//')
  if [ "$version" != "" ];then
    info=$(echo "$json"|grep "\"published_at\":"|cut -d":" -f2|cut -d '"' -f2)
    info="The latest release published on: $info"
  elif [ "$output_detail" -eq 1 ];then
    curl https://api.github.com/repos/$user/$repository/tags
    version=$(curl https://api.github.com/repos/$user/$repository/tags 2>/dev/null|grep "\"name\":"|head -n1|cut -d":" -f2|cut -d '"' -f2|cut -d"/" -f3|sed 's/^v//')
    info="The latest tag"
  fi
  # In case of API limitation
  if [ "$version" = "" ];then
    local url="https://github.com/$user/$repository/releases"
    local html="$(curl "$url" 2>/dev/null)"
    version=$(echo "$html"|grep css-truncate-target|cut -d ">" -f2 |cut -d"<" -f1)
    if [ "$version" != "" ];then
      info="The latest release published on: $(echo "$html"|grep -A1 "released this"|tail -n1|cut -d">" -f2|cut -d"<" -f1)"
    else
      version=$(echo "$html"|grep tag-name|head -n1|cut -d ">" -f2 |cut -d"<" -f1)
      info="The latest tag published on: $(echo "$html"|grep "relative-time"|head -n1|cut -d">" -f2|cut -d"<" -f1)"
    fi
  fi
  if [ "$output_detail" -eq 1 ] && [ "$version" != "" ];then
    printf "%15s %8s %s\n" "$package" "$version" "$info"
  fi
} ## }}}

function get_github_direct_latest { ## {{{
  get_github_latest "$@"
} ## }}}

function xargs_wrapper { ## {{{
  if [ -z "$xargs_opt" ] && [ "${xargs_opt-A}" = "A" ];then
    if echo|xargs -r >/dev/null 2>&1;then
      xargs_opt="-r"
    else
      xargs_opt=""
    fi
  fi
  xargs $xargs_opt "$@"
} ## }}}

function get_file_dir_list { ## {{{
  find "$1" -maxdepth 1 -mindepth 1 -name "$2" -print0 2>/dev/null|xargs_wrapper -0 -n1 basename
} ## }}}

function get_file_list { ## {{{
  find "$1" -maxdepth 1 -mindepth 1 -type f -name "$2" -print0 2>/dev/null|xargs_wrapper -0 -n1 basename
} ## }}}

function get_dir_list { ## {{{
  find "$1" -maxdepth 1 -mindepth 1 -type d -name "$2" -print0 2>/dev/null|xargs_wrapper -0 -n1 basename
} ## }}}

function add_package { ## {{{
  # Ignore share/info/dir which causes a conflict sometime.
  cd_check "$stow_dir"
  stow --ignore="share/info/dir" "$target"
  ret=$?
  if [ $ret -ne 0 ];then
    err "Failed to place pacakge:${target%%-STOW*} by stow."
    exit $ret
  fi
  mkdir -p "$current_dir"
  touch "$current_dir/$target"
} ## }}}

function rm_package { ## {{{
  clean=${1:-0}
  if [ -f "${current_dir}/${target}" ];then
    cd_check "$stow_dir"
    stow -D "$target"
    rm -f "${current_dir}/${target}"
  fi
  if [ "$clean" = "1" ];then
    rm -rf "${stow_dir:?}/${target}"
  fi
} ## }}}

# }}} functions

# Check argumetns {{{

COMMANDS=(install rm remove uninstall list packages cleanup info latest version help)
NEED_ARGS=(uninstall info latest)

if [ "$#" -eq 0 ] || [ "$1" = "help" ] || [ "$1" = "-h" ];then
  show_help 0
elif [ "$1" = "version" ] || [ "$1" = "-v" ];then
  show_version
  exit 0
fi

if ! echo " ${COMMANDS[*]} "|grep -q " $1 ";then
  err "Unknown command: $1"
  exit $EXIT_UNKNOWN_COMMAND
fi
command=$1
shift
if [ "$command" = "rm" ] || [ "$command" = "remove" ];then
  command="uninstall"
fi

while getopts c:d:i:t:fDVvh OPT;do
  case $OPT in
    "c" ) conf_file="$OPTARG" ;;
    "d" ) conf_dir=(${OPTARG/,/ } "${conf_dir[@]}");;
    "i" ) set_inst_dir "$OPTARG" ;;
    "t" ) default_inst_type="$OPTARG" ;;
    "f" ) force=1 ;;
    "D" ) dryrun=1 ;;
    "V" ) verbose=1 ;;
    "v" ) show_version; exit 0;;
    "h" ) show_help 0;;
    * ) echo "Check \"$(basename "$0") -h\" for more information" >/dev/tty;exit $EXIT_WRONG_ARG;;

  esac
done
shift $((OPTIND - 1))

if echo " ${NEED_ARGS[*]} "|grep -q " $command ";then
  if [ "$#" -eq 0 ];then
    err "Need <package> argument for $command command."
    exit $EXIT_NO_PACKAEGE
  fi
fi

if [ "$command" = "latest" ];then
  packages=("$@")
  for package in "$@";do
    source_pac_conf
    get_latest 1
  done
  exit
fi
# }}}

# Read configuration {{{
if [ -f "$conf_file" ];then
  source "$conf_file"
fi
if [ "$#" -ne 0 ];then
  packages=("$@")
fi
# }}}

# Info {{{
if [ "$command" = "info" ];then
  verbose=1
  for package in "${packages[@]}";do
    get_pac_conf "$package" 1
    if [ "$pac_conf" != "" ];then
      banner "Configuration for $package"
      cat "$pac_conf"
    fi
  done
  exit
fi
# }}}

# List {{{
if [ "$command" = "list" ];then
  pac_list=$(get_file_list "$current_dir" "*-STOW-*"|awk '{split($1, tmp, "-STOW-")}{print tmp[1]}')
  if [ -t 1 ];then
    echo "$pac_list"|column
  else
    echo "$pac_list"
  fi
  exit
fi
# }}}

# Packages {{{
if [ "$command" = "packages" ];then
  for d in "${conf_dir[@]}";do
    conf_list=$(get_file_list "$d" "*.sh"|sed 's/.sh$//')
    if [ -t 1 ];then
      echo "$conf_list"|column
    else
      echo "$conf_list"
    fi
  done
  exit
fi

# Clean up {{{
if [ "$command" = "cleanup" ];then
  cleanup_package
  exit
fi
# }}}

# Check PATH/LD_LIBRARY_PATH {{{
if ! echo "$PATH"| grep -q "$inst_dir/bin";then
#  warn "PATH doesn't include $inst_dir/bin,
#which may make a problem to search dependencies or to use stow command."
  export PATH="$inst_dir/bin:$PATH"
fi
if ! echo "$LD_LIBRARY_PATH"| grep -q "$inst_dir/lib";then
#  warn "LD_LIBRARY_PATH doesn't include $inst_dir/lib,
#which may make a problem to search dependencies."
  export LD_LIBRARY_PATH="$inst_dir/lib64:$inst_dir/lib:$LD_LIBRARY_PATH"
fi
if ! echo "$PYTHONPATH"| grep -q "$inst_dir/lib";then
#  warn "LD_LIBRARY_PATH doesn't include $inst_dir/lib,
#which may make a problem to search dependencies."
  export PYTHONPATH="$inst_dir/lib:$PYTHONPATH"
fi
# }}}

# Check necessary packages {{{
necessary_packages=(unzip wget stow)
for p in "${necessary_packages[@]}";do
  if ! type -a "$p" >/dev/null 2>&1;then
    packages=($p "${packages[@]}")
  fi
done
# }}}

# Uninstall {{{
if [ "$command" = "uninstall" ];then
  for package in "${packages[@]}";do
    source_pac_conf
    banner "Uninstalling ${package}"
    rm_package
  done
  exit
fi
# }}}

# Dependency check {{{
i=0
pre_packages=()
while [ "$i" -lt "${#packages[@]}" ];do
  package="${packages[$i]}"
  source_pac_conf
  deps=0
  j=0
  while [ "$j" -lt ${#bin_dep[@]} ];do
    b=${bin_dep[j]}
    p=${b}
    if [[ "$p" =~ _package_ ]];then
      bp=(${p/_package_/ })
      b=${bp[0]}
      p=${bp[1]}
    fi
    if [ "$b" = "" ] || [ "$p" = "" ];then
      err "Configuration file for ${bin_dep[j]} has wrong bin_dep definition."
      exit $EXIT_WRONG_BIN_DEP
    fi
    if ! check_bin "$b";then
      if ! echo " ${pre_packages[*]} "|grep -q " $p ";then
        if echo " ${packages[*]} "|grep -q " $p ";then
          packages=($(echo " ${packages[*]} "|sed "s/ $p / /"))
        fi
        packages=($(echo " ${packages[*]} "|sed "s/ $package / $p $package /"))
        deps=1
      fi
    fi
    ((j++))
  done
  j=0
  while [ "$j" -lt ${#lib_dep[@]} ];do
    p=${lib_dep[j]}
    l=lib${p}
    if [[ "$p" =~ _package_ ]];then
      lp=(${p/_package_/ })
      l=${lp[0]}
      p=${lp[1]}
    fi
    if [ "$l" = "" ] || [ "$p" = "" ];then
      err "Configuration file for ${lib_dep[j]} has wrong lib_dep definition."
      exit $EXIT_WRONG_LIB_DEP
    fi
    if ! check_lib "$l";then
      if ! echo " ${pre_packages[*]} "|grep -q " $p ";then
        if echo " ${packages[*]} "|grep -q " $p ";then
          packages=($(echo " ${packages[*]} "|sed "s/ $p / /"))
        fi
        packages=($(echo " ${packages[*]} "|sed "s/ $package / $p $package /"))
        deps=1
      fi
    fi
    ((j++))
  done
  if [ $deps -eq 0 ];then
    pre_packages=("${pre_packages[@]}" "$package")
    ((i++))
  fi
done
# }}}

# Prepare tmp dir/path {{{
TMP_DIR=$(mktemp -d)
trap 'rm -rf "$TMP_DIR"' EXIT HUP INT QUIT ABRT SEGV TERM
# }}}

# Main loop {{{
for package in "${packages[@]}";do
  source_pac_conf

  if [ "$package" = "stow" ];then
    export PATH=$stow_dir/$target/bin:$PATH
  fi

  if [ -d "$stow_dir/$target" ];then
    banner_v "$target was already installed."
    if [ "$force" -eq 1 ];then
      banner_v "Reinstall $target."
      if [ $dryrun -eq 0 ];then
        rm_package
      fi
    else
      if [ $dryrun -eq 0 ];then
        add_package
      fi
      continue
    fi
  else
    # Uninstall old package
    current_package=$(get_file_list "$current_dir" "${package}-STOW-*")
    if [ "$current_package" != "" ];then
      target_tmp=$target
      for p in ${current_package};do
        target=$p
        rm_package 1
      done
      target=$target_tmp
    fi
  fi

  banner "Installing $stow_dir/$target"

  if [ $dryrun -eq 1 ];then
    continue
  fi

  # Install
  if [ "$verbose" -eq 1 ];then
    stow_install_wrapper
  else
    log=$(stow_install_wrapper 2>&1)
  fi
  ret=$?

  if [ $ret -ne 0 ];then
    if [ "$verbose" -eq 0 ];then
      echo "$log"
    fi
    err "Failed to install $package"
    exit $ret
  fi

  add_package
done # }}}

# vim: foldmethod=marker
# vim: foldmarker={{{,}}}
